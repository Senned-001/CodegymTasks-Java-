taskKey="com.codegym.games.racer.part16"\n\nRacer (Part 16/28)

Currently, the player's car continues to move after colliding with an obstacle. In this part of the project,
we'll implement a method that will check whether the car has hit an obstacle.
When implementing this method, use the GameObject class's isCollision(GameObject) method, which we have implemented for you.
Figure out how it works.

Collisions should be visibly noticeable, i.e. we need to change the image used to display the player's car.
To do this, give the PlayerCar class a stop() method that sets the matrix field to ShapeMatrix.PLAYER_DEAD.


Requirements:
1.	The RoadManager class must have a public boolean checkCrash(PlayerCar) method.
2.	The checkCrash(PlayerCar) must call the GameObject class&#39;s isCollision(GameObject) method on the elements of the items list in order to check for collisions.
3.	The checkCrash(PlayerCar) must return true if the player collides with any of the objects in the items list.
4.	The checkCrash(PlayerCar) must return false if the player has not collided with any of the objects in the items list.
5.	The PlayerCar class must have a public void stop() method.
6.	In the stop() method, the player&#39;s matrix must be replaced by ShapeMatrix.PLAYER_DEAD.


Racer (Part 15/28)

Currently, spikes appear only once (at the beginning of the game). To generate a new spike, the old spike must be removed
from the items list after its leaves the screen. To remove the spike, you can either use an iterator, or
create a copy of the items list and run through it in a loop. If an object needs to be removed, call items.remove(item).



Racer (Part 14/28)

The time has come to draw the spike on the screen.

There must not be more than one Spike object on the screen at the same time.
To check this condition, create a spikeExists() method in the RoadManager class.
To check whether the RoadObject is a spike, you can use its type field.

The void generateSpike(Game) method will be responsible for generating spikes.
It will check whether there is a spike on the road. If not, then a new spike is generated with a 10% probability.
In the future, things other than spikes may be obstacles. We'll need the generateNewRoadObjects(Game) method to generate all different kinds of obstacles, but for now it will only generate spikes. It must be called in the RacerGame class's onTurn(int) method.

Additionally, the spike must move together with the race track in the moveAll() method.



Racer (Part 13/28)

The RoadManager class's name isn't arbitrary: it manages all the obstacles on the road.
It must know how to draw and move all the stored objects.

In the RacerGame class, create a RoadManager roadManager field so you can access it.
Initialize the roadManager field in createGame(), and call draw(Game) on it in drawScene().



Racer (Part 12/28)

Obstacles must appear at random locations on the road.

Add two constants to the RoadManager class: FIRST_LANE_POSITION and FOURTH_LANE_POSITION — the far left and far right road positions
of the x coordinates of the obstacles' matrices. Assign them the values 16 and 44 respectively.

Additionally, the RoadManager class must have a list of all current obstacle objects.

In the same class, create a addRoadObject(RoadObjectType, Game) method that generates a position for a new obstacle and adds it
to the list of all obstacle objects. The obstacle's coordinates must be generated as follows:

x = game.getRandomNumber(FIRST_LANE_POSITION, FOURTH_LANE_POSITION) — a random lane number;
y = -1 * RoadObject.getHeight(type) — initially, the object is placed beyond the playing field so that it makes a smooth appearance.



Racer (Part 11/28)

The player will face various obstacles on the road: other cars driving the wrong way, and spikes that don't move relative
to the race track. These obstacles will inherit the RoadObject class. The types of all possible obstacles are listed in the
RoadObjectType enum. You now have access to these classes in the road package. And new matrices for displaying obstacles
have been added to the ShapeMatrix class. Take a look at the RoadObject class and its methods.

At this stage, we'll implement the spikes. Create a Spike class and make it inherit RoadObject. To create instances of obstacles,
in the RoadManager class, create a private RoadObject createRoadObject(RoadObjectType type, int x, int y) method that will
create and return a new obstacle based on the passed arguments.
We currently only have one type of obstacle: Spike, so if the createRoadObject method receives any other type as an argument,
it should return null. Since we know the game object's type, there is no need to pass an image matrix to its constructor.
Accordingly, the GameObject class will need one more constructor with two int parameters (int x, int y), which are used to
initialize the x and y fields.



