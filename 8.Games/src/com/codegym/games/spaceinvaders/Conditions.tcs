taskKey="com.codegym.games.spaceinvaders.part11"\n\nSpace Invaders (Part 11/34)

When the ships reach the edge of the screen, they begin to move in the opposite direction and drop lower.
To achieve this, we need to implement the EnemyFleet class's move method.


Requirements:
1.	The EnemyFleet class&#39;s move() method does nothing if there are no ships in the ships list.
2.	If the direction field is equal to Direction.LEFT and the getLeftBorder() method returns a negative value, you need to set the direction field equal to Direction.RIGHT.
3.	If the direction field is equal to Direction.RIGHT and the getRightBorder() method returns a value greater than SpaceInvadersGame.WIDTH, you need to set the direction field equal to Direction.LEFT.
4.	In the move() method, you need to call the getSpeed() method.
5.	If the value of the direction field changes, you need to call the move(Direction, double) method with the following arguments on each object in the ships list: Direction.DOWN, value returned by the getSpeed() method.
6.	If the value of the direction field does not change, you need to call the move(Direction, double) method with the following arguments on each object in the ships list: direction, value returned by the getSpeed() method.


Space Invaders (Part 10/34)

According to the rules of the game, the fewer ships there are, the faster they move from side to side.
We'll implement this relationship in the getSpeed method. Note that the enemy ships' speed must not exceed 2.
We'll also give the EnemyFleet class a direction field and a move method.
We'll need to give the SpaceInvadersGame class a moveSpaceObjects method. That's where we'll move objects.
The ships move at each step of the game, so the moveSpaceObjects method must be called in the onTurn method.
To immediately see the movement on the screen, you need to call the moveSpaceObjects method before redrawing the screen.



Space Invaders (Part 9/34)

Everything will move in the game, which means that we need to specify the direction in which objects are moving. It is convenient to store directions in an enum.
We'll describe the motion of an enemy ship in the move() method. The method will change the appropriate coordinate depending on direction and speed.
The downward speed will be a constant 2. Because the enemy fleet moves back and forth between edges of the playing field, we need to watch for when the fleet reaches the edges.



Space Invaders (Part 8/34)

Let's continue working on the enemy fleet. To do this, we need to fill the ships list in the createShips() method.
Keep in mind that the best distance from the top of the screen to the top row of ships is 12 cells.
To add the enemy fleet to the game, we'll create an enemyFleet field in the SpaceInvadersGame class and initialize it to a new EnemyFleet object.
The enemy ships are created when the createShips method is called in the EnemyFleet constructor.
The game is dynamic, so we'll need to regularly redraw the screen and perform other actions. Everything that happens at each step is performed in the onTurn(int) method.
We'll use the setTurnTimer method to set how often this method is called. It takes an argument that determines how long each step is in milliseconds.
In other words, given a step of 40 ms (0.04 second), the onTurn method will be called 25 times per second (1 / 0.04 second).
If you've done everything correctly, you'll see the enemy fleet when you run the program.



Space Invaders (Part 7/34)

In this part of the project, we'll prepare the foundation for the enemy fleet. To do this, we'll create an EnemyFleet class.
It will store the list of ships, number of rows of ships (ROWS_COUNT), number of ships per row (COLUMNS_COUNT),
and distance between left corners of adjacent ships (STEP). We'll create the ships and add them to the ships list in the createShips method,
which we will implement later.



Space Invaders (Part 6/34)

Now we'll create a Ship class that will store properties that all spaceships share. It will have a setStaticView method that at present will set a matrix.
Later, it will set an animation. First, we make a class for ships in the enemy's fleet: EnemyShip. We've provided its matrix for you in the ShapeMatrix class.



