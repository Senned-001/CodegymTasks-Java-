taskKey="com.codegym.task.task33.task3310.big14"\n\nShortener (14)


We've tested our strategies many times using the Solution class's
testStrategy() method. It's time to use JUnit to write real unit tests.
14.1.	Read about unit tests.
14.2.	Download and connect the JUnit 4.12 library. Figure out how to use it.
The JUnit library depends on the hamcrest-core library. Connect it as well. Use version 1.3.
14.3.	Add a FunctionalTest class to the tests package. In this class, we'll check
the functionality of our strategies.
14.4.	Add a testStorage(Shortener shortener) method to the FunctionalTest class. It
must:
14.4.1.	Create three strings. String 1 and 3 should be the same.
14.4.2.	Get and save identifiers for all three strings using
shortener.
14.4.3.	Check that the identifier for String 2 is not equal to the identifier for Strings 1
and 3. Hint: Assert.assertNotEquals method.
14.4.4.	Check that the identifiers for Strings 1 and 3 are equal. Hint: Assert.assertEquals
method.
14.4.5.	Use shortner to get three strings for three ids.
14.4.6.	Check that the strings obtained in the preceding item are the same as the
original. Hint: Assert.assertEquals method.
14.5.	Add tests to the FunctionalTest class:
14.5.1.	testHashMapStorageStrategy()
14.5.2.	testOurHashMapStorageStrategy()
14.5.3.	testFileStorageStrategy()
14.5.4.	testHashBiMapStorageStrategy()
14.5.5.	testDualHashBidiMapStorageStrategy()
14.5.6.	testOurHashBiMapStorageStrategy()
Each test must have a @Test annotation. Create the appropriate strategy.
Create a Shortener object based on the strategy and call the corresponding testStorage
method.
Run the program and verify that all tests pass.



Requirements:
1.	The FunctionalTest class must be added to the created tests package.
2.	In the testStorage method, the getId and getString methods must be called three times.
3.	The test methods listed in the task conditions should be marked only with the @Test annotation.
4.	Each test method must call the testStorage method.


Shortener (13)


Consider another implementation of BiMap â€” this time from Apache Commons Collections.
13.1.	Download and connect Apache Commons Collections 4.0.
13.2.	Implement a DualHashBidiMapStorageStrategy. It must:
13.2.1.	support the StorageStrategy interface.
13.2.2.	have only one DualHashBidiMap data field.
13.3.	Test the new strategy in the main() method. Run the program and compare the performance
of the six strategies.



Shortener (12)


It's not all that uncommon to need to create a Map that works in two directions (from key to
value, and from value to key). Implementations of such collections
already exist in various third-party libraries. One such is guava from
Google.
12.1.	Download and connect the guava library, version 19.0.
12.2.	Implement the HashBiMapStorageStrategy. It must:
12.2.1.	support the StorageStrategy interface.
12.2.2.	have only one HashBiMap data field.
12.3.	Test the new strategy in the main() method. Run the program and compare the performance
of the five strategies.



Shortener (11)


As you've noticed, getting an identifier using a string takes a lot more
time than getting a string using an identifier. This is expected and is a consequence of
HashMap's implementation. Let's write a fourth strategy:
OurHashBiMapStorageStrategy, which will eliminate this shortcoming.
11.1.	Create an OurHashBiMapStorageStrategy class that implements the
StorageStrategy interface.
11.2.	Add two fields: HashMap<Long, String> k2v and HashMap<String, Long> v2k
The first will maintain a mapping from keys to values, and the second will do the opposite: from values
to keys.
11.3.	Implement the StorageStrategy interface's methods, optimizing for
speed. Hint: when a new key-value pair must be added,
add it to two fields at once.
Test the new strategy in the main() method. Run the program and compare the performance of
all 4 strategies. Be sure that we've made it significantly faster to get
an identifier. Of course, you understand that this solution has both advantages and disadvantages.
Think about when it makes sense to use OurHashBiMapStorageStrategy and when
HashMapStorageStrategy would be preferred.



Shortener (10)


Create and implement a FileStorageStrategy class. It must:
10.1.	Implement the StorageStrategy interface.
10.2.	Use FileBucket as a buckets. Hint: The class
must have a FileBucket[] table field.
10.3.	It works like OurHashMapStorageStrategy, but
double the number of buckets not when the number of size elements becomes larger
than some threshold, but rather when the size of one of the buckets (files) became larger than
bucketSizeLimit.
10.3.1.	Add a long bucketSizeLimit field to the class.
10.3.2.	Initialize it with a default value, such as 10,000 bytes.
10.3.3.	Add a setter and getter for this field.
10.4.	When implementing the resize(int newCapacity) method, be sure that the files you no longer need
have been deleted (call the remove() method).
Test the new strategy in the main() method. Bear in mind that the FileStorageStrategy strategy is much
slower than the others. Don't use a large number of elements for the test.
Doing so could take a looooog time.
Run the program and compare the performance of all 3 strategies.

P.S. Be sure that the FileStorageStrategy class has all the necessary fields by analogy with OurHashMapStorageStrategy:
static final int DEFAULT_INITIAL_CAPACITY
static final long DEFAULT_BUCKET_SIZE_LIMIT
FileBucket[] table
int size
private long bucketSizeLimit = DEFAULT_BUCKET_SIZE_LIMIT
long maxBucketSize



Shortener (9)


Let's write another strategy. We'll call it FileStorageStrategy. It will be very similar
to OurHashMapStorageStrategy, but files will be
the buckets. I'm sure you know what I mean by buckets. If not, copy the internal workings
of HashMap.
9.1.	Create a FileBucket class in the strategy package.
9.2.	Add a Path path field to the class. This will be the path to the file.
9.3.	Add a no-argument constructor to the class. It should:
9.3.1.	Initialize the path field with a temporary file. The file must be placed
in the directory for temporary files and have a random name. Hint:
Files.createTempFile.
9.3.2.	Use the path field to create a new file. If the file already exists, then
replace it.
9.3.3.	Ensure the file is deleted when you exit the program. Hint:
deleteOnExit().
9.4.	Add the following methods to the class:
9.4.1. long getFileSize() - Returns the size of the file pointed to
by path.
9.4.2. void putEntry(Entry entry) - Serializes the passed entry to
the file. Be aware that each entry may contain another entry.
9.4.3.	Entry getEntry() - Gets an entry from the file. If the file size is zero,
return null.
9.4.4. void remove() - Delete the file pointed to by path.
The constructor and methods should not throw exceptions.



