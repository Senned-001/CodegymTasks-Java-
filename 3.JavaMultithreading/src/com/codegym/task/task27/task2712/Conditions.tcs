taskKey="com.codegym.task.task27.task2712.big18"\n\nRestaurant (part 18)


Currently, we have one tablet and 1 cook.
Let's create several tablets that will randomly generate orders, and we'll make two cooks.

1. In the Restaurant class, create a constant PRIVATE static int ORDER_CREATION_INTERVAL = 100.

2. In a separate file, create a (Runnable) RandomOrderGeneratorTask class. This task should:
2.1. Maintain a list of all the tablets
2.2. Use Math.random to select a random tablet.
2.3. RandomOrderGeneratorTask should have only one method.
2.4. Generate a random order every ORDER_CREATION_INTERVAL milliseconds for the tablet in item 2.2 (don't display a stack trace)
Now an order is created in the Tablet class's createOrder method.
In the Tablet class, create a void createTestOrder() method with similar functionality
that will randomly generate an order with random dishes without communicating with a real person.
Pass all the necessary data to in the constructor.
Hint:
a) create a TestOrder class (descendant of Order) in the parent's package.
b) in the Order class, create a protected initDishes() method that initializes the dishes. Call this method in the constructor
c) in the Order class, make the dishes field protected
d) override initDishes in the TestOrder class. Initialize the order with a random set of dishes.
e) instead of creating an Order object in the Tablet class's createTestOrder() method, create a TestOrder object.
All of the createTestOrder method's other functionality remains the same

3. Refactor the createTestOrder() and createOrder() methods: in one of the methods, select the code that is repeated in both methods,
press Ctrl+Alt+M, enter any name for the method, and click OK. IDEA will offer to replace the code in the second method. Confirm the action.


Requirements:
1.	A constant private static int ORDER_CREATION_INTERVAL with the value 100 must be created in the Restaurant class.
2.	The RandomOrderGeneratorTask must be implemented in accordance with the task conditions.
3.	The TestOrder class must be implemented in accordance with the task conditions.
4.	The Order class must have an initDishes method that initializes dishes.
5.	The Order class constructor must call the initDishes method.


Restaurant (part 17)


Let's implement the third and fourth statistics items: the lists of active and inactive videos
It will be easier to do this with access to the video repository (AdvertisementStorage class).
1. In the ad package, create a StatisticsAdvertisementManager that will provide information from AdvertisementStorage in the required form.
Make it a singleton.

2. In the StatisticsAdvertisementManager class, create and initialize a AdvertisementStorage field.

3. In the StatisticsAdvertisementManager, create one (or two) methods (you decide) that fetch all the necessary data from the
AdvertisementStorage: the list of active commercials and the list of inactive commercials.
An active video is one that has at least one remaining impression.
An inactive video is one with 0 remaining impressions.

4. Implement the logic of the ManagerTablet class's printActiveVideoSet and printArchivedVideoSet methods.
Use the method(s) created in the previous item.
Sort alphabetically by the name of the video


Example output for printActiveVideoSet:
First Video - 100
Second Video - 10
Third Video - 2
Fourth Video - 4

In this example, printArchivedVideoSet would display the following after 50 impressions:
Second Video
Third Video
Fourth Video



Restaurant (part 16)


Let's implement the first statistics item: advertising revenues, grouped by day.

1. In the VideosSelectedEventDataRow class, create a getter for the amount field.
In the OrderReadyEventDataRow class, create a getter for the cookName field.

2. In StatisticsManager, create a method (come up with its name on your own) that will get all repository data
related to displaying advertising, and will calculate the total revenues for each day.
Additionally, add a get helper method to the repository class to access the data.

3. Let's start with the logic of the printAdRevenue method in the ManagerTablet class.
Using the method from the previous item, display the dates and amounts in decreasing order.
For each date with displayed ads in the event repository, the revenue per impression for that date should be displayed.
At the end, display "Total" and the total amount.
Example:
14-May-2013 - 2.50
13-May-2013 - 1.02
12-May-2013 - 543.98
Total - 547.50

4. Let's implement the second statistics item: cook utilization (time spent working), grouped by day.

In StatisticsManager, create a method (come up with its name on your own) that will get all repository data
related to a cook's work, and will calculate the total time spent working for each cook separately.

5. Implement the logic of the ManagerTablet class's printCookUtilization method.
Using the method from the previous item to display dates, names of cooks, and hours worked (round up), in decreasing order.
For each date in the event repository with a record about work performed by a cook, the time worked on that date in minutes should be displayed.
If a cook did not work on a day, then DO NOT display empty data for him or her (see 13-May-2013)
Sort the cooks by name
Example:
14-May-2013
Puck - 60 min
Ramsay - 35 min

13-May-2013
Puck - 129 min

12-May-2013
Puck - 6 min
Ramsay - 5 min



Restaurant (part 15)


Let's think about what needs to be done so that the manager can view the following:
1) advertising revenues, grouped by day;
2) cook utilization (time spent working), grouped by day;
3) list of active videos and the number of remaining impressions for each;
4) list of inactive videos (with zero remaining impressions).

For each item, we'll add a corresponding method to StatisticsManager.
The manager will call the method, and StatisticsManager will perform the various calculations.
But the manager has to call these methods from somewhere. We'll give him or her a tablet, but with different software.
To do this, we'll create a ManagerTablet class that has a nice interface and the ability to access statistics.

1. Create the ManagerTablet class at the root of the project.

2. In the ManagerTablet class, create four void methods:
printAdRevenue(), printCookUtilization(), printActiveVideoSet(), printArchivedVideoSet()
They correspond to the four items listed above.

3. To make it possible to check the result, in the main method, create a manager's tablet and display statistics
using the methods listed above.

We're going to need some more methods.
4. In EventDataRow, create the following methods:
Date getDate(), which returns the row's creation date
int getTime(), which returns the duration

5. In StatisticsManager, create a void register(Cook cook) method, which will register the cook.
In the StatisticsManager class, create a Set cooks field and add the cook.

6. Implement the necessary getters in the OrderReadyEventDataRow, NoVideosAvailableEventDataRow, and VideosSelectedEventDataRow classes.



Restaurant (part 14)


1. Create a void put(EventDataRow data) method in StatisticsStorage.

2. To allow the put(EventDataRow data) method to add the data object to the map, we need the event type (EventType).
It would make sense for the event to store its type. Therefore,
2.1. Add an EventType getType() method to the EventDataRow interface
2.2. Implement this method in each event class: OrderReadyEventDataRow, NoVideosAvailableEventDataRow, VideosSelectedEventDataRow

3. Make it so that the void put(EventDataRow data) method cannot be accessed outside the StatisticsManager class.
Take advantage of the features of nested classes.

Now it remains to arrange StatisticsManager calls in places that generate events.

4. Record an event for the cook when the food is prepared.
Add a getter for the dishes field to the Order class, and use it when creating the event.

5. Record a "videos selected" event before displaying ads to the customer.

6. The record method with one EventDataRow parameter should record the event in statisticsStorage.



Restaurant (part 13)


Let's return to the StatisticsManager class's record method. It should record events in a repository.
Let's create the repository :)
The repository has a 1-to-1 relationship with the manager, i.e. there is one manager and one repository per application.
Only the StatisticsManager can access the repository. Therefore...
From the above, it follows that the repository must be a private inner class.
Let's call it StatisticsStorage.

1. Inside the StatisticsManager class, create a private inner StatisticsStorage class.

2. To allow the manager to access the repository, you need to create a StatisticsStorage statisticsStorage field in the StatisticsManager class.
Initialize it with an instance of the class.

3. StatisticsStorage will store data internally in a Map storage field.
The StatisticsStorage and Map must have a has-a relationship
The maps type arguments are <EventType, List<EventDataRow>>

4. In the StatisticsStorage constructor, initialize the repository with default data:
for example, use a loop to add a new ArrayList <EventDataRow>() for each EventType.



