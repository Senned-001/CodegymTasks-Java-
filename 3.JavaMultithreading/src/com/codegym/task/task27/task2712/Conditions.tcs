taskKey="com.codegym.task.task27.task2712.big16"\n\nRestaurant (part 16)


Let's implement the first statistics item: advertising revenues, grouped by day.

1. In the VideosSelectedEventDataRow class, create a getter for the amount field.
In the OrderReadyEventDataRow class, create a getter for the cookName field.

2. In StatisticsManager, create a method (come up with its name on your own) that will get all repository data
related to displaying advertising, and will calculate the total revenues for each day.
Additionally, add a get helper method to the repository class to access the data.

3. Let's start with the logic of the printAdRevenue method in the ManagerTablet class.
Using the method from the previous item, display the dates and amounts in decreasing order.
For each date with displayed ads in the event repository, the revenue per impression for that date should be displayed.
At the end, display "Total" and the total amount.
Example:
14-May-2013 - 2.50
13-May-2013 - 1.02
12-May-2013 - 543.98
Total - 547.50

4. Let's implement the second statistics item: cook utilization (time spent working), grouped by day.

In StatisticsManager, create a method (come up with its name on your own) that will get all repository data
related to a cook's work, and will calculate the total time spent working for each cook separately.

5. Implement the logic of the ManagerTablet class's printCookUtilization method.
Using the method from the previous item to display dates, names of cooks, and hours worked (round up), in decreasing order.
For each date in the event repository with a record about work performed by a cook, the time worked on that date in minutes should be displayed.
If a cook did not work on a day, then DO NOT display empty data for him or her (see 13-May-2013)
Sort the cooks by name
Example:
14-May-2013
Puck - 60 min
Ramsay - 35 min

13-May-2013
Puck - 129 min

12-May-2013
Puck - 6 min
Ramsay - 5 min


Requirements:
1.	A getter for the amount field must be created in the VideosSelectedEventDataRow class.
2.	A getter for the cookName field must be created in the OrderReadyEventDataRow class.
3.	The ManagerTablet class&#39;s printAdRevenue method must be implemented in accordance with the task conditions.
4.	The ManagerTablet class&#39;s printCookUtilization method must be implemented in accordance with the task conditions.


Restaurant (part 15)


Let's think about what needs to be done so that the manager can view the following:
1) advertising revenues, grouped by day;
2) cook utilization (time spent working), grouped by day;
3) list of active videos and the number of remaining impressions for each;
4) list of inactive videos (with zero remaining impressions).

For each item, we'll add a corresponding method to StatisticsManager.
The manager will call the method, and StatisticsManager will perform the various calculations.
But the manager has to call these methods from somewhere. We'll give him or her a tablet, but with different software.
To do this, we'll create a ManagerTablet class that has a nice interface and the ability to access statistics.

1. Create the ManagerTablet class at the root of the project.

2. In the ManagerTablet class, create four void methods:
printAdRevenue(), printCookUtilization(), printActiveVideoSet(), printArchivedVideoSet()
They correspond to the four items listed above.

3. To make it possible to check the result, in the main method, create a manager's tablet and display statistics
using the methods listed above.

We're going to need some more methods.
4. In EventDataRow, create the following methods:
Date getDate(), which returns the row's creation date
int getTime(), which returns the duration

5. In StatisticsManager, create a void register(Cook cook) method, which will register the cook.
In the StatisticsManager class, create a Set cooks field and add the cook.

6. Implement the necessary getters in the OrderReadyEventDataRow, NoVideosAvailableEventDataRow, and VideosSelectedEventDataRow classes.



Restaurant (part 14)


1. Create a void put(EventDataRow data) method in StatisticsStorage.

2. To allow the put(EventDataRow data) method to add the data object to the map, we need the event type (EventType).
It would make sense for the event to store its type. Therefore,
2.1. Add an EventType getType() method to the EventDataRow interface
2.2. Implement this method in each event class: OrderReadyEventDataRow, NoVideosAvailableEventDataRow, VideosSelectedEventDataRow

3. Make it so that the void put(EventDataRow data) method cannot be accessed outside the StatisticsManager class.
Take advantage of the features of nested classes.

Now it remains to arrange StatisticsManager calls in places that generate events.

4. Record an event for the cook when the food is prepared.
Add a getter for the dishes field to the Order class, and use it when creating the event.

5. Record a "videos selected" event before displaying ads to the customer.

6. The record method with one EventDataRow parameter should record the event in statisticsStorage.



Restaurant (part 13)


Let's return to the StatisticsManager class's record method. It should record events in a repository.
Let's create the repository :)
The repository has a 1-to-1 relationship with the manager, i.e. there is one manager and one repository per application.
Only the StatisticsManager can access the repository. Therefore...
From the above, it follows that the repository must be a private inner class.
Let's call it StatisticsStorage.

1. Inside the StatisticsManager class, create a private inner StatisticsStorage class.

2. To allow the manager to access the repository, you need to create a StatisticsStorage statisticsStorage field in the StatisticsManager class.
Initialize it with an instance of the class.

3. StatisticsStorage will store data internally in a Map storage field.
The StatisticsStorage and Map must have a has-a relationship
The maps type arguments are <EventType, List<EventDataRow>>

4. In the StatisticsStorage constructor, initialize the repository with default data:
for example, use a loop to add a new ArrayList <EventDataRow>() for each EventType.



Restaurant (part 12)


We have several events:
*The cook prepared an order
*The set of videos for an order has been chosen
*There are no videos that can be shown while an order is prepared

These are constants, so an enum is suitable for representing them.

1. In the event package, create the following: enum EventType {ORDER_READY, VIDEOS_SELECTED, NO_VIDEOS_AVAILABLE}

2. In the event package, create three classes corresponding to the enum fields. They will (should) represent events.
We will record them in the repository.
Here are the class names and constructor parameters:
2.1. OrderReadyEventDataRow(String tabletName, String cookName, int cookingTimeSeconds, List<Dish> dishesInOrder)
where tabletName is the name of the tablet
cookName is the name of the cook
cookingTimeSeconds is the time required to prepare the order in seconds
dishesInOrder is the list of dishes to prepare
2.2. NoVideosAvailableEventDataRow(int totalDuration)
totalDuration is the time required to prepare the order in seconds
2.3. VideosSelectedEventDataRow(List<Advertisement> optimalVideoSet, long amount, int totalDuration)
optimalVideoSet is the list of videos chosen for playback
amount is the amount of money in cents
totalDuration is the total duration of the chosen commercials
3. In the classes created in item 2, add a Date currentDate field, which you will initialize in the constructor with the current date.



Restaurant (part 11)


We've implemented the first two of the three features. You will recall that the first was automated order preparation,
the second was commercial selection, and the third is statistics for the manager. And that's our next step.

We need to implement the following functionality:
1) calculate the statistics
2) display the statistics to the manager

Let's try to determine the sequence of actions. To display data, you must first get it from somewhere.

There are two approaches:
The FIRST approach is applied when it is difficult to obtain real data, or when someone else does the work to get the data:
1. hardcode the data in the application
2. display the hardcoded statistics
3. get the real data/statistics (integrate with someone else's code)

SECOND:
1. get the real data/statistics
2. display the statistics

Because we're implementing this functionality ourselves, and the statistics aren't complicated, we'll adopt the second approach.
Let's start by getting the real data and real statistics.

Here's the idea:
There's an event repository.
When an event occurs, we'll record it in the repository.
Upon a request from the manager, we'll filter the events in the repository, and then calculate and display the necessary data.

First, we need several classes.
1. Create a statistics package, where we'll create a StatisticsManager class. We'll use it to record events in the repository.
2. We should have one repository with one entry point. Therefore, we'll make StatisticsManager a singleton.
3. Inside the statistics package, create a nested event package to store event-related classes.
4. Create an EventDataRow interface in the event package. At the moment, it's a marker interface,
since it doesn't have methods and we use it to determine whether the passed object is an event.
5. In StatisticsManager, create a public void record(EventDataRow data) method that records the event in the repository.
We'll return to the implementation later.



