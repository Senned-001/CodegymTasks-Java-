taskKey="com.codegym.task.task31.task3110.big16"\n\nArchiver (part 16)


It's time to remove something from an archive. An archive is a tricky thing—you can't just go and
remove an element.
Why? Imagine we decided to invent our own text compression algorithm. After examining the source
text, we see that the phrase "being a programmer is cool" occurs often. In the second and subsequent
instances of our phrase, we can replace the phrase with a note that this location represents the same phrase that was used in line S,
starting from character K and N characters long. As we replace a lot of repeated
phrases, the text shrink noticeably, but becomes unreadable to those not familiar with our compression algorithm.
Of course, we can recover the text (extract it). Now imagine what we need to remove
the part of the text that is referenced by the compressed fragments. If we did this, our entire archive would
become meaningless. That's why you can't simply remove part of an archive. This is a highly simplified description
of a compression technique; in reality, everything is far more complicated.
As a result, to remove something from an archive, you need to create a new archive, and copy over everything except
the removed file. Then you replace the old archive with the newly created one.
1.	Add a public void removeFiles(List<Path> pathList)
throws Exception method to the ZipFileManager class. It will remove files from an archive. A list of the relative paths to
the files inside the archive will be passed in pathList. It must:
1.1. Throw a NoSuchZipFileException if the archive file doesn't exist.
1.2. Create a temporary archive file in the default directory using the Files class's createTempFile() method.
1.3. Go through all the files of the original archive, and check whether the current file is in the list
for removal.
- If the file is in the list, display a message indicating that we have removed the corresponding file and
move on to the next file.
- If the file is not in the removal list, copy it to the new archive
1.4. Replace the original archive file with the temporary file we wrote all of the required files to.
You need to do this using the Files class's move() method
2.	Add a public void removeFile(Path path) throws Exception method to the ZipFileManager class.
It should call the removeFiles method, creating a list out of a single element. This can be done using
the Collections class's singletonList() method. Look up how it works.
3.	Implement the ZipRemoveCommand class's execute() method: create a ZipFileManager object,
ask the user which file to remove from which archive, and call the removeFile() method.
Do everything else as we did in the other commands. You don't have to catch the PathNotFoundException, since  the
removeFile() method shouldn't throw it.
4.	Run the program and verify that removing a file from an archive works.


Requirements:
1.	You need to create a public void removeFiles(List&lt;Path&gt; pathList) throws Exception method in the ZipFileManager class.
2.	The removeFiles method must throw a NoSuchZipFileException if the archive file doesn&#39;t exist.
3.	The removeFiles method must create a temporary archive file using the Files.createTempFile method.
4.	The removeFiles method should write all of the files from the old archive to the new archive, except those in the list for removal.
5.	In the ZipFileManager class, you need to create a public void removeFile(Path path) throws Exception method that delegates the call to the removeFiles(List&lt;Path&gt; pathList) method.
6.	The ZipRemoveCommand class&#39;s execute() method should get the ZipFileManager object and remove from the archive the file read from the console.


Archiver (part 15)


It's time to try to extract something. To do this, add a public void extractAll(Path
outputFolder) throws Exception method to the ZipFileManager class. The Path outputFolder parameter is the path to which we will
extract our archive. You already have extensive experience working with zip entries and streams, so I'll
only give you some hints on how to implement this method. You'll have to think carefully about how
to do the following:
1.	Check whether the zip file exists
2.	If the outputFolder directory does not exist, then it needs to be created, along with all the folders that
contain it.
3.	Inside the archive, some files may be inside folders. In this case, the ZipEntry.getName() method
doesn't exactly return the file name, as might be expected from the method name. Instead, it returns the file's relative path
inside the archive. This relative path should be retained after the extraction process is complete, but
it will become relative to the directory where we have extracted the archive
4.	Implement the ZipExtractCommand class's execute() method by analogy with our implementation of
ZipCreateCommand. Make a similar try-catch block, and simply change the displayed messages
so that the user knows we are currently extracting an archive, and that we need the archive's
full name and the directory to which we will extract the archive. Don't forget to call the
ZipFileManager class's extractAll method, and not createZip like we did in the ZipCreateCommand
5.	Run the program and enjoy the extracted results

Note:
Use Files.newInputStream(Path path) and Files.newOutputStream(Path path) to get read and write streams.



Archiver (part 14)


Everything is ready to implement the ZipContentCommand class's execute() method:
1.	Display "Viewing contents of the archive."
2.	Create a ZipFileManager object using the getZipFileManager() method
3.	Display "Archive contents:"
4.	Get a list of the archive's files using the getFileList() method
5.	Display the properties of each file. The previously implemented
FileProperties.toString() method will come in handy
6.	Display "Archive contents viewed."
7.	Run the program and verify that the "View the contents of an archive" command works



Archiver (part 13)


Let's continue to move toward getting the contents of an archive. Let's write a getFileList() method inside the
ZipFileManager class. It will return a list of the files in the archive, or rather a list of the properties of these files (
we already implemented the FileProperties class). Let's begin:
1.	Add a List<FileProperties> getFileList() throws Exception method to the ZipFileManager class.
2.	Inside that method, check whether zipFile is a regular file using
a suitable method from the Files class. If it is not a file, throw a NoSuchZipFileException.
3.	Create a list of FileProperties objects. We'll add the file properties to it.
4.	Create a ZipInputStream for the file represented by the zipFile variable. As we've done before, wrap the creation of this object
in a try-with-resources.
5.	Go through all of the ZipEntries in the ZipInputStream
6.	For each ZipEntry, read its contents (otherwise, we won't have information about its
size). You can't find the size of a file in an archive without reading it. This is super easy to do
using the copyData method and a temporary ByteArrayOutputStream buffer.
7.	Get the name, size, compressed size, and compression method of the zip entry. Take a look at what else you can
learn about the entry.
8.	Create a FileProperties object using the obtained file data.
9.	Add the object created in step 8 to the list from step 3.
10.	Return the gathered information to the method that called the getFileList method.



Archiver (part 12)


Today we'll prepare to implement ZipContentCommand. It will be responsible for getting
an archive's contents. The archive's contents are compressed files and folders, but we're interested
in knowing not only the names of the archive's objects, but also their size before and after compression,  their compression ratio, and
the compression method used.
We'll create a FileProperties class that will be responsible for the properties of each file in the archive. Out set of properties
consists of the following: file name, file size before and after compression, and compression method.
1.	Create the FileProperties class
2.	Add the following private instance variables to it:
2.1. String name - The file name
2.2. long size - The size in bytes
2.3. long compressedSize - The size after compression in bytes
2.4. int compressionMethod - The compression method
3.	Add getters for them
4.	Add a FileProperties(String name, long size, long compressedSize, int
compressionMethod) constructor
5.	Add a long getCompressionRatio() method that will calculate the compression ratio as:
100 - ((compressedSize * 100) / size)
6.	Override the String toString() method so that it returns a String formatted as follows:
"name size KB (compressedSize KB) compression: compressionRatio%" if the file size is greater than 0. Otherwise, it should
only return the file name. For example, a directory might have a size of 0. Don't forget
to convert bytes to kilobytes. Note that the number of bytes in a kilobyte isn't the same as the number of grams in a kilogram. Nor is it the same as the number of
chips in that bag... Hmm, maybe it's time for me to grab a snack…



Archiver (part 11)


Finally, we'll try to provide a decent implementation for the ZipCreateCommand class's execute() method that
we added previously. To do this, we need to:
1.	Display "Creating an archive." at the beginning of the method. Don't forget that we are using
the ConsoleHelper class to work with the console.
2.	Create a new ZipFileManager object. Since we will also need to create this object
in other commands, move the creation logic to a separate ZipFileManager getZipFileManager() throws
Exception method in the ZipCommand class. This method should:
2.1. Ask the user to enter the full path to the archive
2.2. Read the path into a String variable
2.3. Use the entered String to create a Path variable
2.4. Create a ZipFileManager object, passing the obtained path to the constructor
2.5. Return the created object
3.	Ask the user to enter the full path to the file or directory to be zipped
4.	Create a Path using the entered String
5.	Call the ZipFileManager object's createZip() method, passing the path from step 4 to it
6.	Display "Archive created."
7.	Wrap the contents of the ZipCreateCommand's execute() method in a try-catch block and catch
PathNotFoundException exceptions. If one occurs, display the message: "You
didn't correctly enter a file name or directory."
8.	Run the program and verify that the "Zip files into an archive" command works



