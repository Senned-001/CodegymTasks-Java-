taskKey="com.codegym.task.task31.task3110.big05"\n\nArchiver (part 5)


Let's divide the commands into two types: those that work directly with the archive, and helpers
(for example, EXIT). All the commands of the first type will have shared functionality. It's convenient to pull this functionality
into a common base class. Let's call this class ZipCommand. Like all command classes, it must
implement the Command interface. All commands that work with an archive must
inherit the ZipCommand class. We won't create any ZipCommand objects, so
let's make it abstract.
1.	Create an abstract ZipCommand class that implements the Command interface
2.	Create a class for each command. All of the listed commands must
inherit ZipCommand and have an empty execute() method. We'll write
the implementation for each command separately as we implement our archiver.
2.1. ZipCreateCommand is the command for creating an archive (zipping files into an archive)
2.2. ZipContentCommand is the command for viewing an archive's contents
2.3. ZipExtractCommand is the command for extracting an archive
2.4. ZipAddCommand is the command for adding a file to an archive
2.5. ZipRemoveCommand is the command for removing a file from an archive


Requirements:
1.	The command package must have an abstract ZipCommand class that implements the Command interface.
2.	The command package must have a ZipCreateCommand class that inherits ZipCommand.
3.	The command package must have a ZipContentCommand class that inherits ZipCommand.
4.	The command package must have a ZipExtractCommand class that inherits ZipCommand.
5.	The command package must have a ZipAddCommand class that inherits ZipCommand.
6.	The command package must have a ZipRemoveCommand class that inherits ZipCommand.


Archiver (part 4)


Each command implies the execution of some action. Create a Command interface with
an execute() method.  We'll create a separate class
for each command. All of the command classes must implement (inherit) the Command interface.
Since there will be a lot of commands, we'll create a separate command package for them. We'll store all of the command-related
interfaces and implementations in it.
The simplest command is EXIT, so let's start with that.
1.	Create the command package
2.	Declare the Command interface in it
3.	Add a void execute() throws Exception method to the Command interface
4.	Declare an ExitCommand class that implements the Command interface
5.	Implement the execute() method in the ExitCommand class. It should use the ConsoleHelper class to display
"Bye!"
6.	At the very end of the Archiver class's main method, add code that creates an
ExitCommand object and calls its execute() method
7.	Check that it all works
Note that all the project files must be encoded in UTF-8. You can set the encoding in IntelliJ IDEA
under Settings -> Editor -> File Encodings. Be sure that all three fields responsible for encoding
are set to UTF-8.



Archiver (part 3)


As you can see, zipping isn't that bad. But our archiver is somehow
too primitive. A real archiver should be able to do much more: extract an archive,
add a new file to an existing archive, remove a file from an archive, and view the contents
of an archive. Now let's improve our archiver. To do that, we have to write a few new
classes. First, let's create an Operation enum, which will contain all the commands that
our archiver supports.
It would also be convenient to use ConsoleHelper to work with the console so that everything console-related
is gathered into the same class. Going forward, unless indicated otherwise, all input and output
should happen through ConsoleHelper.
1.	Declare the Operation enum, and add the following commands to it:
1.1. CREATE - Create an archive
1.2. ADD - Add a file to an archive
1.3. REMOVE - Remove a file from an archive
1.4. EXTRACT - Extract an archive's contents
1.5. CONTENT - View an archive's contents
1.6. EXIT - Exit the program
2.	Create a ConsoleHelper class and implement the following static public methods in it:
2.1. void writeMessage(String message) - Display a message on the console
2.2. String readString() - Read a String from the console
2.3. int readInt() - Read a number from the console
Methods that read from the console can throw an IOException if an input error occurs. Account for
this in their declarations.



Archiver (part 2)


Now let's implement the createZip(Path source) method, which will zip the file
specified by the source argument.
Java has a special ZipOutputStream class in the java.util.zip package. It compresses (zips) the
data passed to it. To keep multiple files from blending together when they are compressed into one archive,
we create a special entity called a ZipEntry for each of them. In other words, we
first put a ZipEntry in the ZipOutputStream, and then we write the file's contents. When the file is written, it is automatically
compressed, and when it is read, it is automatically decompressed. A ZipEntry doesn't have to be a file; it can also be a
folder.
To zip a file (create a new archive and add the file to it):
1.	Create a new ZipOutputStream using the zipFile variable and the
Files class's newOutputStream method.
2.	Create a new ZipEntry. Pass a String containing the new entry's name to the ZipEntry constructor.
You need to get the name from the full path source. Get only the file name and convert it to a String.
3.	Add the created zip entry to the zip stream.
4.	Copy the data from the file we are zipping to the zip stream. To do this:
4.1. Create an InputStream for the source file using the Files class's newInputStream method.
4.2. Make a loop that will read data from the InputStream (created in 4.1) as long as it has data and write
that data to the ZipOutputStream (created in step 1)
4.3. Close the InputStream using a try-with-resources
5.	Close the zip stream's zip entry
6.	Close the zip stream using a try-with-resources
7.	Run the program and verify that a file can be zipped



Archiver (part 1)


Let's write an archiver. At a minimum, an archiver should be able to zip and unzip
files. Let's start with the first one.
We need an archive manager. It will perform operations on the archive file (a file that
will be stored on disk and have the zip extension). The class that will handle this will be called
ZipFileManager. But the most important class will be called Archiver.
Programming and other fields have a concept called full (absolute) and relative paths. First off,
let's wrap our heads around what a path is, in general. A path is a set of symbols that indicates where in
the operating system a file or folder is located.
A full or absolute path is a path that starts with the root directory. In Windows,
a disk is generally considered the root directory. An example of a full path in Windows is:
C:\user\zips\Test1.zip.
A relative path is a path relative to a directory. For example, zips\Test1.zip
is the relative path of the file Test1.zip in relation to the C:\user directory (folder). The path
relative to the C:\user\zips directory would just be Test1.zip, and would match the file name.
Note that, by default, both the full and relative path to a file include the name
of the file.
1.	Create a ZipFileManager class
2.	Add a private Path zipFile variable to the class. We will use it to store the full path to the archive
that we will be working with.
3.	Add a ZipFileManager(Path zipFile) constructor. Initialize the class's zipFile field.
4.	Declare a public createZip(Path source) throws Exception method with, for now, an empty implementation.
The Path source parameter is a path to something that we will zip.
5.	Create an Archiver class and add a main method to it.
6.	In the main method:
6.1 Ask the user to enter the full path to the archive from the keyboard. Don't forget that the file name is also
part of the full path.
6.2 Create a ZipFileManager object, passing in the archive's file name. Figure out how to get
a Path from a String. Hint: look into the Paths class's get() method.
6.3 Ask the user to enter the path to the file to be zipped. Don't confuse this with
the archive file, which we already entered. This time, we need the file that we'll
compress, not the one we're going to store the compressed data in.
6.4 Call the ZipFileManager object's createZip method, passing the path to be zipped.



