taskKey="com.codegym.task.task30.task3008.big13"\n\nChat (part 13)


Let's continue to implement helper methods in the Client class.

Add the followings methods, which will be available to subclasses,
but not to other classes outside the package:
1) String getServerAddress() - It should ask the user to enter the server address,
and return the entered value. The address can be a string containing
an IP address if the client and server are running on different machines or 'localhost' if the client and
server are running on the same machine.
2) int getServerPort() - It should ask the user to enter the server port, and then return it.
3) String getUserName() - It should ask for and return the username.
4) boolean shouldSendTextFromConsole() - In this implementation of the client, it
should always return true (we always send the text entered from the console). This
method can be overridden if we write another
client that inherits ours and shouldn't send the text entered
from the console.
5) SocketThread getSocketThread() - It should create and return a new
SocketThread object.
6) void sendTextMessage(String text) - It creates a new text message,
using the connection field to send the passed text to the server.
If an IOException occurs while the text is sent, you need to display
information about this user and assign false to the clientConnected field.


Requirements:
1.	The getServerAddress() method should return a string (server address) read from the console.
2.	The getServerPort() method should return a number (server port) read from the console.
3.	The getUserName() method should return a string (username) read from the console.
4.	The shouldSendTextFromConsole() method should return true.
5.	The sendTextMessage() method should create and send a new text message using the connection field, and set the clientConnected flag to false if an IOException occurs while sending or creating the message.
6.	The getSocketThread() method should return a new SocketThread object.


Chat (part 12)


Let's start writing the client. When the client starts running, it should request the server address and server port,
connect to the specified address, receive a name request from the server, ask the user for his or her name,
send the username to the server, and wait for the server to accept the name.
After that, the client can exchange text messages with the server.
Messages will be exchanged on two threads running in parallel.
One will read from the console and send what is read to the server, and the second thread will receive data
from the server and display it on the console.

Let's start the client implementation:
1) Create a client package. From now on, create all classes responsible for the client implementation in this package.
2) Create a Client class.
3) In the Client class, create a nested SocketThread class that inherits the Thread
class. It will be responsible for the thread that establishes the socket connection and
reads server messages. The class must have a public access modifier.
4) Create a Connection connection field in the Client class. Use an access modifier that will allow access
to this field from subclasses, but will prevent calls from classes outside the package.
5) Add a private boolean clientConnected field to the Client class. Initialize it to false.
It will subsequently be set to true if the client connected to the server, or false otherwise.
When declaring this field, use a keyword that will ensure that every thread using the clientConnected field
will be working with the current value, not a cached value.



Chat (part 11)


It's time to write the main method of the Handler class, which will call all
the helper methods we wrote earlier. Implement the void run() method in the Handler class.

It must:
1) Display a message indicating that a new connection was established with a remote
address that can be obtained using the getRemoteSocketAddress() method.
2) Create a Connection object using the socket field.
3) Call the method that implements the handshake with the client, and store the name of the new client.
4) Send the name of the new participant (USER_ADDED message) to all chat participants.
Think about which method is most suitable for this.
5) Inform the new participant about the existing participants.
6) Start the server's main message-processing loop.
7) Be sure that the connection is closed if an exception occurs.
8) If any IOExceptions or ClassNotFoundExceptions occur, catch them and display a message indicating
that an error occurred while communicating with the remote address.
9) After handling any exceptions, if step 11.3 has finished and returned a name, we need to remove
from connectionMap the entry for that name and send a USER_REMOVED message containing the name to all other participants.
10) The last thing we need to do in the run() method is display a message
indicating that the connection with the remote address is closed.

Our server is completely ready. Try running it.



Chat (part 10)


The third stage is the server's main message-processing loop.
Add a private void serverMainLoop(Connection connection, String userName) throws IOException, ClassNotFoundException
method, where the meaning of the parameters is the same as in the notifyUsers() method.

It must:
1) Receive client messages
2) If a received message is text (TEXT), then generate a new text message by concatenating the client name,
a colon, a space, and the text message. For example, if we received a message with the text
"Hi, everyone" from the user "Bob", then you would need to generate this message: "Bob: Hi, everyone".
3) Send the generated message to all clients using the sendBroadcastMessage() method.
4) If the received message is not text, display an error message
5) Create an infinite loop and move the functionality of steps 10.1-10.4 into the loop.



Chat (part 9)


The second stage, which is no less important, is sending information to the client (new participant) about the
other clients (chat participants).

To do this:
1) Add a private void notifyUsers(Connection connection, String userName) throws IOException method,
where connection is the connection with the participant we are sending information to,
and userName is that participant's name. The method should:
2) Iterate over connectionMap.
3) For each element in step 2, get the client name, generate a USER_ADDED message that includes the passed name.
4) Use the connection field to send the generated message.
5) Don't send a USER_ADDED message to the user whose name is equal to userName.
The user already knows about himself or herself.



Chat (part 8)


The Handler class must implement the client communication protocol.
Let's identify independent stages of the protocol and implement them in separate methods:
The first stage is the handshake (in which the server meets the client).
We'll implement it in the private String method serverHandshake(Connection connection) throws IOException,
ClassNotFoundException method. The method takes a connection as an argument, and returns the name of the new client.

The implementation should:
1) Generate and send a username request
2) Get the client's response
3) Verify that the response has a username
4) Extract the name from the response, and verify that it is not empty and is not already being used (use connectionMap)
5) Add the new user and connection to connectionMap
6) Send an informational message to the client, informing it that the name was accepted
7) If any verification step fails, request the client's name again
8) Return the accepted name as the return value



